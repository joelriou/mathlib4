/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.AlgebraicTopology.SimplicialSet.Basic
import Mathlib.CategoryTheory.Subpresheaf.OfSection

/-!
# Subcomplexes of a simplicial set

Given a simplicial set `X`, this file defines the type `X.Subcomplex`
of subcomplexes of `X` as an abbreviation for `Subpresheaf X`.
It also introduces a coercion from `X.Subcomplex` to `SSet`.

## Implementation note

`SSet.{u}` is defined as `C·µí·µñ ‚•§ Type u`, but it is not an abbreviation.
This is the reason why `Subpresheaf.Œπ` is redefined here as `Subcomplex.Œπ`
so that this morphism appears as a morphism in `SSet` instead of a morphism
in the category of presheaves.

-/

universe u

open CategoryTheory Simplicial Limits

namespace SSet

-- Note: this could be obtained as `inferInstanceAs (Balanced (_ ‚•§ _))`
-- by importing `Mathlib.CategoryTheory.Adhesive`, but we give a
-- different proof so as to reduce imports
instance : Balanced SSet.{u} where
  isIso_of_mono_of_epi f _ _ := by
    rw [NatTrans.isIso_iff_isIso_app]
    intro
    rw [isIso_iff_bijective]
    constructor
    ¬∑ rw [‚Üê mono_iff_injective]
      infer_instance
    ¬∑ rw [‚Üê epi_iff_surjective]
      infer_instance

variable (X Y : SSet.{u})

/-- The complete lattice of subcomplexes of a simplicial set. -/
abbrev Subcomplex := Subpresheaf X

variable {X Y}

namespace Subcomplex

/-- The underlying simplicial set of a subcomplex. -/
abbrev toSSet (A : X.Subcomplex) : SSet.{u} := A.toPresheaf

instance : CoeOut X.Subcomplex SSet.{u} where
  coe := fun S ‚Ü¶ S.toSSet

/-- If `A : Subcomplex X`, this is the inclusion `A ‚ü∂ X` in the category `SSet`. -/
abbrev Œπ (A : Subcomplex X) : Quiver.Hom (V := SSet) A X := Subpresheaf.Œπ A

instance (A : X.Subcomplex) : Mono A.Œπ :=
  inferInstanceAs (Mono (Subpresheaf.Œπ A))

section

variable {S‚ÇÅ S‚ÇÇ : X.Subcomplex} (h : S‚ÇÅ ‚â§ S‚ÇÇ)

/-- Given an inequality `S‚ÇÅ ‚â§ S‚ÇÇ` between subcomplexes of a simplicial set,
this is the induced morphism in the category `SSet`. -/
abbrev homOfLE : (S‚ÇÅ : SSet.{u}) ‚ü∂ (S‚ÇÇ : SSet.{u}) := Subpresheaf.homOfLe h

@[reassoc]
lemma homOfLE_comp {S‚ÇÉ : X.Subcomplex} (h' : S‚ÇÇ ‚â§ S‚ÇÉ) :
    homOfLE h ‚â´ homOfLE h' = homOfLE (h.trans h') := rfl

variable (S‚ÇÅ) in
@[simp]
lemma homOfLE_refl : homOfLE (by rfl : S‚ÇÅ ‚â§ S‚ÇÅ) = ùüô _ := rfl

@[simp]
lemma homOfLE_app_val (Œî : SimplexCategory·µí·µñ) (x : S‚ÇÅ.obj Œî) :
    ((homOfLE h).app Œî x).val = x.val := rfl

@[reassoc (attr := simp)]
lemma homOfLE_Œπ : homOfLE h ‚â´ S‚ÇÇ.Œπ = S‚ÇÅ.Œπ := rfl

instance mono_homOfLE : Mono (homOfLE h) := mono_of_mono_fac (homOfLE_Œπ h)

/-- This is the isomorphism of simplicial sets corresponding to
an equality of subcomplexes. -/
@[simps]
def isoOfEq (h : S‚ÇÅ = S‚ÇÇ) : (S‚ÇÅ : SSet.{u}) ‚âÖ S‚ÇÇ where
  hom := homOfLE h.le
  inv := homOfLE h.symm.le

end

/-- The functor which sends `A : X.Subcomplex` to `A.toSSet`. -/
@[simps]
def toSSetFunctor : X.Subcomplex ‚•§ SSet.{u} where
  obj A := A
  map h := homOfLE (leOfHom h)

section

variable (X)

/-- If `X : SSet`, this is the isomorphism of simplicial sets
from `‚ä§ : X.Subcomplex` to `X`. -/
@[simps! inv_app_coe]
def topIso : ((‚ä§ : X.Subcomplex) : SSet) ‚âÖ X :=
  NatIso.ofComponents (fun n ‚Ü¶ (Equiv.Set.univ (X.obj n)).toIso)

@[simp]
lemma topIso_hom : (topIso X).hom = Subcomplex.Œπ _ := rfl

@[reassoc (attr := simp)]
lemma topIso_inv_Œπ : (topIso X).inv ‚â´ Subpresheaf.Œπ _ = ùüô _ := rfl

end

instance : Subsingleton (((‚ä• : X.Subcomplex) : SSet.{u}) ‚ü∂ Y) where
  allEq _ _ := by ext _ ‚ü®_, h‚ü©; simp at h

instance : Unique (((‚ä• : X.Subcomplex) : SSet.{u}) ‚ü∂ Y) where
  default :=
    { app := by rintro _ ‚ü®_, h‚ü©; simp at h
      naturality _ _ _ := by ext ‚ü®_, h‚ü©; simp at h }
  uniq := by subsingleton

/-- If `X` is a simplicial set, then the empty subcomplex of `X` is an initial
object in `SSet`. -/
def isInitialBot : IsInitial ((‚ä• : X.Subcomplex) : SSet.{u}) :=
  IsInitial.ofUnique _

/-- The subcomplex of a simplicial set that is generated by a simplex. -/
abbrev ofSimplex {n : ‚Ñï} (x : X _‚¶ãn‚¶å) : X.Subcomplex := Subpresheaf.ofSection x

lemma mem_ofSimplex_obj {n : ‚Ñï} (x : X _‚¶ãn‚¶å) :
    x ‚àà (ofSimplex x).obj _ :=
  Subpresheaf.mem_ofSection_obj x

lemma ofSimplex_le_iff {n : ‚Ñï} (x : X _‚¶ãn‚¶å) (A : X.Subcomplex) :
    ofSimplex x ‚â§ A ‚Üî x ‚àà A.obj _ :=
  Subpresheaf.ofSection_le_iff _ _

lemma mem_ofSimplex_obj_iff {n : ‚Ñï} (x : X _‚¶ãn‚¶å) {m : SimplexCategory·µí·µñ} (y : X.obj m) :
    y ‚àà (ofSimplex x).obj m ‚Üî ‚àÉ (f : m.unop ‚ü∂ ‚¶ãn‚¶å), X.map f.op x = y := by
  dsimp [ofSimplex, Subpresheaf.ofSection]
  aesop

section

variable (f : X ‚ü∂ Y)

/-- The range of a morphism of simplicial sets, as a subcomplex. -/
abbrev range : Y.Subcomplex := Subpresheaf.range f

/-- The morphism `X ‚ü∂ Subcomplex.range f` induced by `f : X ‚ü∂ Y`. -/
abbrev toRange : X ‚ü∂ Subcomplex.range f := Subpresheaf.toRange f

@[reassoc (attr := simp)]
lemma toRange_Œπ : toRange f ‚â´ (Subcomplex.range f).Œπ = f := rfl

@[simp]
lemma toRange_app_val {Œî : SimplexCategory·µí·µñ} (x : X.obj Œî) :
    ((toRange f).app Œî x).val = f.app Œî x := rfl

instance : Epi (toRange f) :=
  inferInstanceAs (Epi (Subpresheaf.toRange f))

instance [Mono f] : Mono (toRange f) :=
  mono_of_mono_fac (toRange_Œπ f)

instance [Mono f] : IsIso (toRange f) :=
  isIso_of_mono_of_epi _

lemma range_eq_top_iff : Subcomplex.range f = ‚ä§ ‚Üî Epi f := by
  rw [NatTrans.epi_iff_epi_app, Subpresheaf.ext_iff, funext_iff]
  simp only [epi_iff_surjective, Subpresheaf.range_obj, Subpresheaf.top_obj,
    Set.top_eq_univ, Set.range_eq_univ]

lemma range_eq_top [Epi f] : Subcomplex.range f = ‚ä§ := by
  rwa [range_eq_top_iff]

end

section

variable (f : X ‚ü∂ Y) {B : Y.Subcomplex} (hf : range f ‚â§ B)

/-- Given a morphism of simplicial sets `f : X ‚ü∂ Y` whose
range is `‚â§ B` for some `B : Y.Subcomplex`, this is the
induced morphism `X ‚ü∂ B`. -/
def lift : X ‚ü∂ B := Subpresheaf.lift f hf

@[reassoc (attr := simp)]
lemma lift_Œπ : lift f hf ‚â´ B.Œπ = f := rfl

@[simp]
lemma lift_app_coe {n : SimplexCategory·µí·µñ} (x : X.obj n) :
    ((lift f hf).app _ x).1 = f.app _ x := rfl

end

section

/-- The preimage of a subcomplex by a morphism of simplicial sets. -/
@[simps]
def preimage (A : X.Subcomplex) (p : Y ‚ü∂ X) : Y.Subcomplex where
  obj n := p.app n ‚Åª¬π' (A.obj n)
  map f := (Set.preimage_mono (A.map f)).trans (by
    simp only [Set.preimage_preimage, FunctorToTypes.naturality _ _ p f]
    rfl)

@[simp]
lemma preimage_max (A B : X.Subcomplex) (p : Y ‚ü∂ X) :
    (A ‚äî B).preimage p = A.preimage p ‚äî B.preimage p := rfl

@[simp]
lemma preimage_min (A B : X.Subcomplex) (p : Y ‚ü∂ X) :
    (A ‚äì B).preimage p = A.preimage p ‚äì B.preimage p := rfl

@[simp]
lemma preimage_iSup {Œπ : Type*} (A : Œπ ‚Üí X.Subcomplex) (p : Y ‚ü∂ X) :
    (‚®Ü i, A i).preimage p = ‚®Ü i, (A i).preimage p := by aesop

@[simp]
lemma preimage_iInf {Œπ : Type*} (A : Œπ ‚Üí X.Subcomplex) (p : Y ‚ü∂ X) :
    (‚®Ö i, A i).preimage p = ‚®Ö i, (A i).preimage p := by aesop

end

section

variable (A : X.Subcomplex) (f : X ‚ü∂ Y)

/-- The image of a subcomplex by a morphism of simplicial sets. -/
@[simps!]
def image : Y.Subcomplex := Subpresheaf.image A f

lemma image_le_iff (Z : Y.Subcomplex) :
    A.image f ‚â§ Z ‚Üî A ‚â§ Z.preimage f := by
  simp [Subpresheaf.le_def]

lemma image_top : (‚ä§ : X.Subcomplex).image f = range f := by aesop

@[simp]
lemma image_id : A.image (ùüô _) = A := by aesop

lemma image_comp {Z : SSet.{u}} (g : Y ‚ü∂ Z) :
    A.image (f ‚â´ g) = (A.image f).image g := by aesop

lemma range_comp {Z : SSet.{u}} (g : Y ‚ü∂ Z) :
    Subcomplex.range (f ‚â´ g) = (Subcomplex.range f).image g := by aesop

lemma image_eq_range : A.image f = range (A.Œπ ‚â´ f) := by aesop

lemma image_iSup {Œπ : Type*} (S : Œπ ‚Üí X.Subcomplex) (f : X ‚ü∂ Y) :
    image (‚®Ü i, S i) f = ‚®Ü i, (S i).image f := by
  aesop

@[simp]
lemma preimage_range : (range f).preimage f = ‚ä§ :=
  le_antisymm (by simp) (by rw [‚Üê image_le_iff, image_top])

@[simp]
lemma image_le_range : A.image f ‚â§ range f := by
  simp only [image_le_iff, preimage_range, le_top]

@[simp]
lemma image_ofSimplex {n : ‚Ñï} (x : X _‚¶ãn‚¶å) (f : X ‚ü∂ Y) :
    (ofSimplex x).image f = ofSimplex (f.app _ x) := by
  apply le_antisymm
  ¬∑ rw [image_le_iff, ofSimplex_le_iff, preimage_obj, Set.mem_preimage]
    apply mem_ofSimplex_obj
  ¬∑ rw [ofSimplex_le_iff]
    exact ‚ü®x, mem_ofSimplex_obj _, rfl‚ü©

/-- Given a morphism of simplicial sets `f : X ‚ü∂ Y` and a subcomplex `A` of `X`,
this is the induced morphism from `A` to `A.image f`. -/
@[simps!]
def toImage : (A : SSet) ‚ü∂ (A.image f : SSet) :=
  (A.image f).lift (A.Œπ ‚â´ f) (by rw [image_eq_range])

@[reassoc (attr := simp)]
lemma toImage_Œπ : A.toImage f ‚â´ (A.image f).Œπ = A.Œπ ‚â´ f := rfl

instance : Epi (A.toImage f) := by
  rw [‚Üê range_eq_top_iff]
  apply le_antisymm (by simp)
  rintro m ‚ü®_, ‚ü®y, hy, rfl‚ü©‚ü© _
  exact ‚ü®‚ü®y, hy‚ü©, rfl‚ü©

lemma image_monotone : Monotone (fun (S : X.Subcomplex) ‚Ü¶ S.image f) := by
  intro S T h
  rw [image_le_iff]
  exact h.trans (by rw [‚Üê image_le_iff])

end

lemma preimage_eq_top_iff (B : X.Subcomplex) (f : Y ‚ü∂ X) :
    B.preimage f = ‚ä§ ‚Üî range f ‚â§ B := by
  rw [‚Üê image_top, image_le_iff, top_le_iff]

@[simp]
lemma image_preimage_le (B : X.Subcomplex) (f : Y ‚ü∂ X) :
    (B.preimage f).image f ‚â§ B := by
  rw [image_le_iff]

/-- Given a morphism of simplicial sets `p : Y ‚ü∂ X` and
`A : X.Subcomplex`, this is the induced morphism
`(A.preimage p : SSet) ‚ü∂ (A : SSet)`. -/
@[simps!]
def fromPreimage (A : X.Subcomplex) (p : Y ‚ü∂ X) :
    (A.preimage p : SSet) ‚ü∂ (A : SSet) :=
  lift (Subcomplex.Œπ _ ‚â´ p) (by simp [range_comp])

@[reassoc (attr := simp)]
lemma fromPreimage_Œπ (A : X.Subcomplex) (p : Y ‚ü∂ X) :
    A.fromPreimage p ‚â´ A.Œπ = (A.preimage p).Œπ ‚â´ p := rfl

end Subcomplex

end SSet
