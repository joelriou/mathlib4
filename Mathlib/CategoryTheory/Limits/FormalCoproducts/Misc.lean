/-
Copyright (c) 2026 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Comma.LocallySmall
public import Mathlib.CategoryTheory.Limits.Constructions.Over.Basic
public import Mathlib.CategoryTheory.Limits.FormalCoproducts.ExtraDegeneracy
public import Mathlib.CategoryTheory.Limits.Types.Coproducts
public import Mathlib.CategoryTheory.Subfunctor.Sieves
public import Mathlib.CategoryTheory.ShrinkYoneda

/-!
# ???

-/

@[expose] public section

universe w v u

namespace CategoryTheory

open Opposite Limits

variable {C : Type u} [Category.{v} C] [LocallySmall.{w} C]

-- to be moved
noncomputable def isTerminalShrinkYonedaObj {T : C} (hT : IsTerminal T) :
    IsTerminal (shrinkYoneda.{w}.obj T) :=
  Functor.isTerminal (fun _ ‚Ü¶ (Types.isTerminalEquivUnique _).2
    { default := shrinkYonedaObjObjEquiv.symm (hT.from _)
      uniq _ := shrinkYonedaObjObjEquiv.injective (hT.hom_ext _ _)})

namespace Limits.FormalCoproduct

variable (U : FormalCoproduct.{w} C)

/-- The augmented simplicial Cech presheaf of types attached to `U : FormalCoproduct.{w} C`,
the target of the augmentation is the subfunctor of the constant functor `C·µí·µñ ‚•§ Type w`
with value `PUnit` that is generated by the objects `U.obj`. -/
noncomputable def shrinkYonedaCech [HasFiniteProducts C] :
    SimplicialObject.Augmented (C·µí·µñ ‚•§ Type w) where
  left := ((SimplicialObject.whiskering _ _).obj
      ((FormalCoproduct.eval C _).obj shrinkYoneda)).obj U.cech
  right := (Subfunctor.ofObjects.{w} U.obj).toFunctor
  hom :=
    { app n :=
      { app V v := ‚ü®.unit, by
          obtain ‚ü®‚ü®i‚ü©, v, rfl‚ü© := Types.jointly_surjective_of_isColimit
            (isColimitOfPreserves ((evaluation _ _).obj V) (coproductIsCoproduct _)) v
          let œÜ : Opposite.unop V ‚ü∂ U.obj (i 0) :=
            shrinkYonedaObjObjEquiv v ‚â´ Pi.œÄ _ 0
          simp [Subfunctor.ofObjects_obj_eq_univ œÜ] ‚ü© } }

lemma isEmpty_shrinkYonedaCechRightObj [HasFiniteProducts C]
    (X : C·µí·µñ) (hX : ‚àÄ (i : U.I), IsEmpty (X.unop ‚ü∂ U.obj i)) :
    IsEmpty (U.shrinkYonedaCech.right.obj X) := by
  simp [shrinkYonedaCech, Subfunctor.ofObjects_obj_eq_empty]

noncomputable def extraDegeneracyShrinkYonedaCech
    [HasFiniteProducts C] {T : C} {i : U.I} (f : T ‚ü∂ U.obj i) (hT : IsTerminal T) :
    U.shrinkYonedaCech.ExtraDegeneracy := by
  refine .ofIso ?_ ((U.extraDegeneracyCech hT f).map
    ((FormalCoproduct.eval C _).obj shrinkYoneda))
  refine Comma.isoMk (Iso.refl _)
    (IsTerminal.uniqueUpToIso ?_
      (Subfunctor.isTerminalOfObjectsToFunctor _ f hT)) ?_
  ¬∑ exact IsTerminal.ofIso (isTerminalShrinkYonedaObj hT)
      { hom := Sigma.Œπ (fun _ ‚Ü¶ _) PUnit.unit
        inv := Sigma.desc (fun _ ‚Ü¶ ùüô _) }
  ¬∑ ext : 1
    apply (Subfunctor.isTerminalOfObjectsToFunctor _ f hT).hom_ext

variable [HasFiniteLimits C]

def shrinkYonedaCechOverIso (X : C) :
    ((SimplicialObject.Augmented.whiskering _ _).obj
      ((Functor.whiskeringLeft _ _ _).obj (Over.forget X).op)).obj U.shrinkYonedaCech ‚âÖ
        ((Over.star X).mapFormalCoproduct.obj U).shrinkYonedaCech := by
  sorry

instance nonempty_extraDegeneracy_shrinkYonedaCech_evaluation (X : C·µí·µñ) :
    Nonempty (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj X)).obj U.shrinkYonedaCech).ExtraDegeneracy := by
  by_cases hX : ‚àÉ i, Nonempty (X.unop ‚ü∂ U.obj i)
  ¬∑ obtain ‚ü®i, ‚ü®f‚ü©‚ü© := hX
    exact ‚ü®.ofIso (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj (op (Over.mk (ùüô _))))).mapIso
        (U.shrinkYonedaCechOverIso X.unop)).symm
          (SimplicialObject.Augmented.ExtraDegeneracy.map
            (extraDegeneracyShrinkYonedaCech _ (Over.homMk (prod.lift (ùüô _) f))
              Over.mkIdTerminal) _)‚ü©
  ¬∑ simp only [not_exists, not_nonempty_iff] at hX
    have := U.isEmpty_shrinkYonedaCechRightObj X hX
    exact ‚ü®.ofIso (Comma.isoMk (NatIso.ofComponents
      (fun n ‚Ü¶ Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by
        rw [Types.initial_iff_empty]
        exact Function.isEmpty (Œ≤ := (U.shrinkYonedaCech.right.obj X))
          ((U.shrinkYonedaCech.hom.app n).app X)))) (fun _ ‚Ü¶ by ext ‚ü®‚ü©))
      (Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by rwa [Types.initial_iff_empty])))
        (by ext : 1; apply Types.isInitialPEmpty.hom_ext)) (.const (PEmpty.{w + 1}))‚ü©

end Limits.FormalCoproduct

end CategoryTheory
