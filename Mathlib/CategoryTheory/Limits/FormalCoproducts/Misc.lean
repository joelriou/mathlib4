/-
Copyright (c) 2026 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Comma.LocallySmall
public import Mathlib.CategoryTheory.Limits.Constructions.Over.Basic
public import Mathlib.CategoryTheory.Limits.FormalCoproducts.ExtraDegeneracy
public import Mathlib.CategoryTheory.Limits.Types.Coproducts
public import Mathlib.CategoryTheory.Subfunctor.Sieves
public import Mathlib.CategoryTheory.ShrinkYoneda

/-!
# ???

-/

@[expose] public section

universe w t v v' u u'

namespace CategoryTheory

variable {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]

open Opposite Limits

-- to be moved
noncomputable def isTerminalShrinkYonedaObj [LocallySmall.{w} C]
    {T : C} (hT : IsTerminal T) :
    IsTerminal (shrinkYoneda.{w}.obj T) :=
  Functor.isTerminal (fun _ ‚Ü¶ (Types.isTerminalEquivUnique _).2
    { default := shrinkYonedaObjObjEquiv.symm (hT.from _)
      uniq _ := shrinkYonedaObjObjEquiv.injective (hT.hom_ext _ _)})

namespace Subfunctor

variable {F : D ‚•§ C} {G : C ‚•§ D} (adj : F ‚ä£ G) {Œπ : Type*} (U : Œπ ‚Üí C)

-- to be moved
def ofObjectsIsoOfAdj :
    F.op ‚ãô (ofObjects U).toFunctor ‚âÖ
      (ofObjects (G.obj ‚àò U)).toFunctor :=
  NatIso.ofComponents (fun X ‚Ü¶ Equiv.toIso ((Equiv.refl _).subtypeEquiv (fun _ ‚Ü¶ by
    simp only [Functor.op_obj, Functor.const_obj_obj, ofObjects, Set.mem_setOf_eq,
      Function.comp_apply, Equiv.refl_apply]
    constructor
    ¬∑ rintro ‚ü®i, ‚ü®f‚ü©‚ü©
      exact ‚ü®i, ‚ü®adj.homEquiv _ _ f‚ü©‚ü©
    ¬∑ rintro ‚ü®i, ‚ü®f‚ü©‚ü©
      exact ‚ü®i, ‚ü®(adj.homEquiv _ _).symm f‚ü©‚ü©))) (fun _ ‚Ü¶ rfl)

end Subfunctor

namespace Adjunction

variable [LocallySmall.{w} C] [LocallySmall.{w} D]
  {F : D ‚•§ C} {G : C ‚•§ D} (adj : F ‚ä£ G)

noncomputable def shrinkYonedaIso :
    (shrinkYoneda.{w} ‚ãô (Functor.whiskeringLeft _ _ _).obj F.op) ‚âÖ
      G ‚ãô shrinkYoneda.{w} :=
  NatIso.ofComponents
    (fun X ‚Ü¶ NatIso.ofComponents
      (fun Y ‚Ü¶ Equiv.toIso (
        shrinkYonedaObjObjEquiv.trans ((adj.homEquiv Y.unop X).trans
          shrinkYonedaObjObjEquiv.symm))) (fun f ‚Ü¶ by
            ext g
            obtain ‚ü®g, rfl‚ü© := shrinkYonedaObjObjEquiv.symm.surjective g
            dsimp
            rw [shrinkYoneda_obj_map_shrinkYonedaObjObjEquiv_symm,
              shrinkYoneda_obj_map_shrinkYonedaObjObjEquiv_symm]
            simp [adj.homEquiv_naturality_left])) (fun f ‚Ü¶ by
            ext _ g
            obtain ‚ü®g, rfl‚ü© := shrinkYonedaObjObjEquiv.symm.surjective g
            dsimp
            rw [shrinkYoneda_map_app_shrinkYonedaObjObjEquiv_symm,
              shrinkYoneda_map_app_shrinkYonedaObjObjEquiv_symm,
              Equiv.apply_symm_apply, Equiv.apply_symm_apply,
              adj.homEquiv_naturality_right])

end Adjunction

namespace Limits.FormalCoproduct

variable [LocallySmall.{w} C] [LocallySmall.{w} D]

open Functor

section

variable {F : D ‚•§ C} {G : C ‚•§ D} (adj : F ‚ä£ G)

noncomputable def evalShrinkYonedaCompIsoOfAdj :
    (eval C _).obj shrinkYoneda.{w} ‚ãô (whiskeringLeft _ _ _).obj F.op ‚âÖ
      G.mapFormalCoproduct ‚ãô (eval _ _).obj shrinkYoneda := by
  refine ?_ ‚â™‚â´ (eval C _).mapIso (adj.shrinkYonedaIso)
  sorry

end

variable (U : FormalCoproduct.{w} C)

@[simps!]
noncomputable def mapFormalCoproductObjPowerIso
    (G : C ‚•§ D) (Œ± : Type t) [HasProductsOfShape Œ± C]
    [HasProductsOfShape Œ± D] [PreservesLimitsOfShape (Discrete Œ±) G] :
    G.mapFormalCoproduct.obj (U.power Œ±) ‚âÖ
      (G.mapFormalCoproduct.obj U).power Œ± :=
  FormalCoproduct.isoOfComponents (Equiv.refl _)
    (fun _ ‚Ü¶ PreservesProduct.iso _ _)

noncomputable def cechCompMapFormalCoproductIso
    [HasFiniteProducts C] [HasFiniteProducts D] (G : C ‚•§ D)
    [PreservesFiniteProducts G] :
    U.cech ‚ãô G.mapFormalCoproduct ‚âÖ (G.mapFormalCoproduct.obj U).cech :=
  NatIso.ofComponents (fun _ ‚Ü¶ mapFormalCoproductObjPowerIso _ _ _) (fun f ‚Ü¶ by
    ext g
    ¬∑ dsimp
    ¬∑ dsimp
      ext i
      simp only [map_lift_piComparison, Function.comp_apply, Category.comp_id,
        Category.assoc, limit.lift_œÄ, Fan.mk_pt, Fan.mk_œÄ_app]
      exact (Pi.lift_œÄ ..).trans (piComparison_comp_œÄ _ _ _).symm)

/-- The augmented simplicial Cech presheaf of types attached to `U : FormalCoproduct.{w} C`,
the target of the augmentation is the subfunctor of the constant functor `C·µí·µñ ‚•§ Type w`
with value `PUnit` that is generated by the objects `U.obj`. -/
noncomputable def shrinkYonedaCech [HasFiniteProducts C] :
    SimplicialObject.Augmented (C·µí·µñ ‚•§ Type w) where
  left := ((SimplicialObject.whiskering _ _).obj
      ((FormalCoproduct.eval C _).obj shrinkYoneda)).obj U.cech
  right := (Subfunctor.ofObjects.{w} U.obj).toFunctor
  hom :=
    { app n :=
      { app V v := ‚ü®.unit, by
          obtain ‚ü®‚ü®i‚ü©, v, rfl‚ü© := Types.jointly_surjective_of_isColimit
            (isColimitOfPreserves ((evaluation _ _).obj V) (coproductIsCoproduct _)) v
          let œÜ : Opposite.unop V ‚ü∂ U.obj (i 0) :=
            shrinkYonedaObjObjEquiv v ‚â´ Pi.œÄ _ 0
          simp [Subfunctor.ofObjects_obj_eq_univ œÜ]‚ü© } }

lemma isEmpty_shrinkYonedaCechRightObj [HasFiniteProducts C]
    (X : C·µí·µñ) (hX : ‚àÄ (i : U.I), IsEmpty (X.unop ‚ü∂ U.obj i)) :
    IsEmpty (U.shrinkYonedaCech.right.obj X) := by
  simp [shrinkYonedaCech, Subfunctor.ofObjects_obj_eq_empty]

noncomputable def extraDegeneracyShrinkYonedaCech
    [HasFiniteProducts C] {T : C} {i : U.I} (f : T ‚ü∂ U.obj i) (hT : IsTerminal T) :
    U.shrinkYonedaCech.ExtraDegeneracy := by
  refine .ofIso ?_ ((U.extraDegeneracyCech hT f).map
    ((FormalCoproduct.eval C _).obj shrinkYoneda))
  refine Comma.isoMk (Iso.refl _)
    (IsTerminal.uniqueUpToIso ?_
      (Subfunctor.isTerminalOfObjectsToFunctor _ f hT)) ?_
  ¬∑ exact IsTerminal.ofIso (isTerminalShrinkYonedaObj hT)
      { hom := Sigma.Œπ (fun _ ‚Ü¶ _) PUnit.unit
        inv := Sigma.desc (fun _ ‚Ü¶ ùüô _) }
  ¬∑ ext : 1
    apply (Subfunctor.isTerminalOfObjectsToFunctor _ f hT).hom_ext


section

variable {F : D ‚•§ C} {G : C ‚•§ D} (adj : F ‚ä£ G) [HasFiniteProducts C]
  [HasFiniteProducts D]

noncomputable def shrinkYonedaCechIsoOfAdj :
    ((SimplicialObject.Augmented.whiskering _ _).obj
      ((whiskeringLeft _ _ _).obj F.op)).obj U.shrinkYonedaCech ‚âÖ
    (G.mapFormalCoproduct.obj U).shrinkYonedaCech :=
  haveI := adj.isRightAdjoint
  Comma.isoMk ((whiskeringRightObjCompIso _ _).app _ ‚â™‚â´
      isoWhiskerLeft _
        (FormalCoproduct.evalShrinkYonedaCompIsoOfAdj adj) ‚â™‚â´
        (associator _ _ _).symm ‚â™‚â´
      isoWhiskerRight (U.cechCompMapFormalCoproductIso G) _)
    (Subfunctor.ofObjectsIsoOfAdj adj _) rfl

end

variable [HasFiniteLimits C]

instance nonempty_extraDegeneracy_shrinkYonedaCech_evaluation (X : C·µí·µñ) :
    Nonempty (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj X)).obj U.shrinkYonedaCech).ExtraDegeneracy := by
  by_cases hX : ‚àÉ i, Nonempty (X.unop ‚ü∂ U.obj i)
  ¬∑ obtain ‚ü®i, ‚ü®f‚ü©‚ü© := hX
    exact ‚ü®.ofIso (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj (op (Over.mk (ùüô _))))).mapIso
        (U.shrinkYonedaCechIsoOfAdj (Over.forgetAdjStar X.unop))).symm
          (SimplicialObject.Augmented.ExtraDegeneracy.map
            (extraDegeneracyShrinkYonedaCech _ (Over.homMk (prod.lift (ùüô _) f))
              Over.mkIdTerminal) _)‚ü©
  ¬∑ simp only [not_exists, not_nonempty_iff] at hX
    have := U.isEmpty_shrinkYonedaCechRightObj X hX
    exact ‚ü®.ofIso (Comma.isoMk (NatIso.ofComponents
      (fun n ‚Ü¶ Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by
        rw [Types.initial_iff_empty]
        exact Function.isEmpty (Œ≤ := (U.shrinkYonedaCech.right.obj X))
          ((U.shrinkYonedaCech.hom.app n).app X)))) (fun _ ‚Ü¶ by ext ‚ü®‚ü©))
      (Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by rwa [Types.initial_iff_empty])))
        (by ext : 1; apply Types.isInitialPEmpty.hom_ext)) (.const (PEmpty.{w + 1}))‚ü©

end Limits.FormalCoproduct

end CategoryTheory
