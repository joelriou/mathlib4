/-
Copyright (c) 2026 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
module

public import Mathlib.CategoryTheory.Comma.LocallySmall
public import Mathlib.CategoryTheory.Limits.Constructions.Over.Basic
public import Mathlib.CategoryTheory.Limits.FormalCoproducts.ExtraDegeneracy
public import Mathlib.CategoryTheory.Limits.Types.Coproducts
public import Mathlib.CategoryTheory.Subfunctor.Sieves
public import Mathlib.CategoryTheory.ShrinkYoneda

/-!
# ???

-/

@[expose] public section

universe w v v' u u'

namespace CategoryTheory

variable {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]
open Opposite Limits

--(eval C (C·µí·µñ ‚•§ Type w)).obj shrinkYoneda.{w, v, u} ‚ãô
-- (Functor.whiskeringLeft D·µí·µñ C·µí·µñ (Type w)).obj F.op

namespace Subfunctor

variable {F : D ‚•§ C} {G : C ‚•§ D} (adj : F ‚ä£ G) {Œπ : Type*} (U : Œπ ‚Üí C)

-- to be moved
def ofObjectsIsoOfAdj :
    F.op ‚ãô (ofObjects U).toFunctor ‚âÖ
      (ofObjects (G.obj ‚àò U)).toFunctor :=
  NatIso.ofComponents (fun X ‚Ü¶ Equiv.toIso ((Equiv.refl _).subtypeEquiv (fun _ ‚Ü¶ by
    simp only [Functor.op_obj, Functor.const_obj_obj, ofObjects, Set.mem_setOf_eq,
      Function.comp_apply, Equiv.refl_apply]
    constructor
    ¬∑ rintro ‚ü®i, ‚ü®f‚ü©‚ü©
      exact ‚ü®i, ‚ü®adj.homEquiv _ _ f‚ü©‚ü©
    ¬∑ rintro ‚ü®i, ‚ü®f‚ü©‚ü©
      exact ‚ü®i, ‚ü®(adj.homEquiv _ _).symm f‚ü©‚ü©))) (fun _ ‚Ü¶ rfl)

end Subfunctor

variable [LocallySmall.{w} C] [LocallySmall.{w} D]

-- to be moved
noncomputable def isTerminalShrinkYonedaObj {T : C} (hT : IsTerminal T) :
    IsTerminal (shrinkYoneda.{w}.obj T) :=
  Functor.isTerminal (fun _ ‚Ü¶ (Types.isTerminalEquivUnique _).2
    { default := shrinkYonedaObjObjEquiv.symm (hT.from _)
      uniq _ := shrinkYonedaObjObjEquiv.injective (hT.hom_ext _ _)})

namespace Limits.FormalCoproduct

variable (U : FormalCoproduct.{w} C)

/-- The augmented simplicial Cech presheaf of types attached to `U : FormalCoproduct.{w} C`,
the target of the augmentation is the subfunctor of the constant functor `C·µí·µñ ‚•§ Type w`
with value `PUnit` that is generated by the objects `U.obj`. -/
noncomputable def shrinkYonedaCech [HasFiniteProducts C] :
    SimplicialObject.Augmented (C·µí·µñ ‚•§ Type w) where
  left := ((SimplicialObject.whiskering _ _).obj
      ((FormalCoproduct.eval C _).obj shrinkYoneda)).obj U.cech
  right := (Subfunctor.ofObjects.{w} U.obj).toFunctor
  hom :=
    { app n :=
      { app V v := ‚ü®.unit, by
          obtain ‚ü®‚ü®i‚ü©, v, rfl‚ü© := Types.jointly_surjective_of_isColimit
            (isColimitOfPreserves ((evaluation _ _).obj V) (coproductIsCoproduct _)) v
          let œÜ : Opposite.unop V ‚ü∂ U.obj (i 0) :=
            shrinkYonedaObjObjEquiv v ‚â´ Pi.œÄ _ 0
          simp [Subfunctor.ofObjects_obj_eq_univ œÜ]‚ü© } }

lemma isEmpty_shrinkYonedaCechRightObj [HasFiniteProducts C]
    (X : C·µí·µñ) (hX : ‚àÄ (i : U.I), IsEmpty (X.unop ‚ü∂ U.obj i)) :
    IsEmpty (U.shrinkYonedaCech.right.obj X) := by
  simp [shrinkYonedaCech, Subfunctor.ofObjects_obj_eq_empty]

noncomputable def extraDegeneracyShrinkYonedaCech
    [HasFiniteProducts C] {T : C} {i : U.I} (f : T ‚ü∂ U.obj i) (hT : IsTerminal T) :
    U.shrinkYonedaCech.ExtraDegeneracy := by
  refine .ofIso ?_ ((U.extraDegeneracyCech hT f).map
    ((FormalCoproduct.eval C _).obj shrinkYoneda))
  refine Comma.isoMk (Iso.refl _)
    (IsTerminal.uniqueUpToIso ?_
      (Subfunctor.isTerminalOfObjectsToFunctor _ f hT)) ?_
  ¬∑ exact IsTerminal.ofIso (isTerminalShrinkYonedaObj hT)
      { hom := Sigma.Œπ (fun _ ‚Ü¶ _) PUnit.unit
        inv := Sigma.desc (fun _ ‚Ü¶ ùüô _) }
  ¬∑ ext : 1
    apply (Subfunctor.isTerminalOfObjectsToFunctor _ f hT).hom_ext


section

variable {F : D ‚•§ C} {G : C ‚•§ D} (adj : F ‚ä£ G) [HasFiniteProducts C]
  [HasFiniteProducts D]

noncomputable def shrinkYonedaCechIsoOfAdj :
    ((SimplicialObject.Augmented.whiskering _ _).obj
      ((Functor.whiskeringLeft _ _ _).obj F.op)).obj U.shrinkYonedaCech ‚âÖ
    (G.mapFormalCoproduct.obj U).shrinkYonedaCech :=
  Comma.isoMk (by
    dsimp [shrinkYonedaCech]
    refine (Functor.whiskeringRightObjCompIso ..).app _ ‚â™‚â´ ?_
    sorry) (Subfunctor.ofObjectsIsoOfAdj adj _) rfl

end

--def shrinkYonedaCechOverIso (X : C) :
--    ((SimplicialObject.Augmented.whiskering _ _).obj
--      ((Functor.whiskeringLeft _ _ _).obj (Over.forget X).op)).obj U.shrinkYonedaCech ‚âÖ
--        ((Over.star X).mapFormalCoproduct.obj U).shrinkYonedaCech := by
--  exact U.shrinkYonedaCechIsoOfAdj (Over.forgetAdjStar X)

variable [HasFiniteLimits C]

instance nonempty_extraDegeneracy_shrinkYonedaCech_evaluation (X : C·µí·µñ) :
    Nonempty (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj X)).obj U.shrinkYonedaCech).ExtraDegeneracy := by
  by_cases hX : ‚àÉ i, Nonempty (X.unop ‚ü∂ U.obj i)
  ¬∑ obtain ‚ü®i, ‚ü®f‚ü©‚ü© := hX
    exact ‚ü®.ofIso (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj (op (Over.mk (ùüô _))))).mapIso
        (U.shrinkYonedaCechIsoOfAdj (Over.forgetAdjStar X.unop))).symm
          (SimplicialObject.Augmented.ExtraDegeneracy.map
            (extraDegeneracyShrinkYonedaCech _ (Over.homMk (prod.lift (ùüô _) f))
              Over.mkIdTerminal) _)‚ü©
  ¬∑ simp only [not_exists, not_nonempty_iff] at hX
    have := U.isEmpty_shrinkYonedaCechRightObj X hX
    exact ‚ü®.ofIso (Comma.isoMk (NatIso.ofComponents
      (fun n ‚Ü¶ Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by
        rw [Types.initial_iff_empty]
        exact Function.isEmpty (Œ≤ := (U.shrinkYonedaCech.right.obj X))
          ((U.shrinkYonedaCech.hom.app n).app X)))) (fun _ ‚Ü¶ by ext ‚ü®‚ü©))
      (Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by rwa [Types.initial_iff_empty])))
        (by ext : 1; apply Types.isInitialPEmpty.hom_ext)) (.const (PEmpty.{w + 1}))‚ü©

end Limits.FormalCoproduct

end CategoryTheory
