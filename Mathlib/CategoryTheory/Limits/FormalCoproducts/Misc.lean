/-
Copyright (c) 2026 Joël Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joël Riou
-/
module

public import Mathlib.CategoryTheory.Limits.FormalCoproducts.ExtraDegeneracy
public import Mathlib.CategoryTheory.Limits.Types.Coproducts
public import Mathlib.CategoryTheory.Subfunctor.Sieves
public import Mathlib.CategoryTheory.ShrinkYoneda

/-!
# ???

-/

@[expose] public section

universe w v u

namespace CategoryTheory

open Opposite Limits

variable {C : Type u} [Category.{v} C] [LocallySmall.{w} C] [HasFiniteProducts C]

namespace Limits.FormalCoproduct

variable (U : FormalCoproduct.{w} C)

/-- The augmented simplicial Cech presheaf of types attached to `U : FormalCoproduct.{w} C`,
the target of the augmentation is the subfunctor of the constant functor `Cᵒᵖ ⥤ Type w`
with value `PUnit` that is generated by the objects `U.obj`. -/
noncomputable def shrinkYonedaCech :
    SimplicialObject.Augmented (Cᵒᵖ ⥤ Type w) where
  left := ((SimplicialObject.whiskering _ _).obj
      ((FormalCoproduct.eval.{w} C _).obj shrinkYoneda.{w})).obj U.cech
  right := (Subfunctor.ofObjects.{w} U.obj).toFunctor
  hom :=
    { app n :=
      { app V v := ⟨.unit, by
          obtain ⟨⟨i⟩, v, rfl⟩ := Types.jointly_surjective_of_isColimit
            (isColimitOfPreserves ((evaluation _ _).obj V) (coproductIsCoproduct _)) v
          let φ : Opposite.unop V ⟶ U.obj (i 0) :=
            shrinkYonedaObjObjEquiv v ≫ Pi.π _ 0
          simp [Subfunctor.ofObjects_obj_eq_univ φ] ⟩ } }

lemma isEmptyShrinkYonedaCechRightObj (X : Cᵒᵖ) (hX : ∀ (i : U.I), IsEmpty (X.unop ⟶ U.obj i)) :
    IsEmpty (U.shrinkYonedaCech.right.obj X) := by
  simp [shrinkYonedaCech, Subfunctor.ofObjects_obj_eq_empty]

section

variable {X : C} {i : U.I} (f : X ⟶ U.obj i)

end

instance nonempty_extraDegeneracy_shrinkYonedaCech_evaluation (X : Cᵒᵖ) :
    Nonempty (((SimplicialObject.Augmented.whiskering _ _).obj
      ((evaluation _ _).obj X)).obj U.shrinkYonedaCech).ExtraDegeneracy := by
  by_cases hX : ∃ i, Nonempty (X.unop ⟶ U.obj i)
  · obtain ⟨i, f⟩ := hX
    sorry
  · simp only [not_exists, not_nonempty_iff] at hX
    have := U.isEmptyShrinkYonedaCechRightObj X hX
    exact ⟨.ofIso (Comma.isoMk (NatIso.ofComponents
      (fun n ↦ Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by
        rw [Types.initial_iff_empty]
        exact Function.isEmpty (β := (U.shrinkYonedaCech.right.obj X))
          ((U.shrinkYonedaCech.hom.app n).app X)))) (fun _ ↦ by ext ⟨⟩))
      (Types.isInitialPEmpty.uniqueUpToIso (Nonempty.some (by rwa [Types.initial_iff_empty])))
        (by ext : 1; apply Types.isInitialPEmpty.hom_ext)) (.const (PEmpty.{w + 1}))⟩

end Limits.FormalCoproduct

end CategoryTheory
